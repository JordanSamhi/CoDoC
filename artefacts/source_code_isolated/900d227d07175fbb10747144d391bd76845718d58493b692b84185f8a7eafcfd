public Mesh create(){
    mRS.validate();
    long[] vtx = new long[mVertexTypeCount];
    long[] idx = new long[mIndexTypes.size()];
    int[] prim = new int[mIndexTypes.size()];
    Allocation[] vertexBuffers = new Allocation[mVertexTypeCount];
    Allocation[] indexBuffers = new Allocation[mIndexTypes.size()];
    Primitive[] primitives = new Primitive[mIndexTypes.size()];
    for (int ct = 0; ct < mVertexTypeCount; ct++) {
        Allocation alloc = null;
        Entry entry = mVertexTypes[ct];
        if (entry.t != null) {
            alloc = Allocation.createTyped(mRS, entry.t, mUsage);
        } else if (entry.e != null) {
            alloc = Allocation.createSized(mRS, entry.e, entry.size, mUsage);
        } else {
            throw new IllegalStateException("Builder corrupt, no valid element in entry.");
        }
        vertexBuffers[ct] = alloc;
        vtx[ct] = alloc.getID(mRS);
    }
    for (int ct = 0; ct < mIndexTypes.size(); ct++) {
        Allocation alloc = null;
        Entry entry = (Entry) mIndexTypes.elementAt(ct);
        if (entry.t != null) {
            alloc = Allocation.createTyped(mRS, entry.t, mUsage);
        } else if (entry.e != null) {
            alloc = Allocation.createSized(mRS, entry.e, entry.size, mUsage);
        } else {
            throw new IllegalStateException("Builder corrupt, no valid element in entry.");
        }
        long allocID = (alloc == null) ? 0 : alloc.getID(mRS);
        indexBuffers[ct] = alloc;
        primitives[ct] = entry.prim;
        idx[ct] = allocID;
        prim[ct] = entry.prim.mID;
    }
    long id = mRS.nMeshCreate(vtx, idx, prim);
    Mesh newMesh = new Mesh(id, mRS);
    newMesh.mVertexBuffers = vertexBuffers;
    newMesh.mIndexBuffers = indexBuffers;
    newMesh.mPrimitives = primitives;
    return newMesh;
}