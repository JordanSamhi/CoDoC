public void initWindow(CCLayout ccLayout, Cea708CCParser.CaptionWindow captionWindow){
    if (mCCLayout != ccLayout) {
        if (mCCLayout != null) {
            mCCLayout.removeOnLayoutChangeListener(this);
        }
        mCCLayout = ccLayout;
        mCCLayout.addOnLayoutChangeListener(this);
        updateWidestChar();
    }
    float scaleRow = (float) captionWindow.anchorVertical / (captionWindow.relativePositioning ? ANCHOR_RELATIVE_POSITIONING_MAX : ANCHOR_VERTICAL_MAX);
    float scaleCol = (float) captionWindow.anchorHorizontal / (captionWindow.relativePositioning ? ANCHOR_RELATIVE_POSITIONING_MAX : ANCHOR_HORIZONTAL_16_9_MAX);
    if (scaleRow < 0 || scaleRow > 1) {
        Log.i(TAG, "The vertical position of the anchor point should be at the range of 0 " + "and 1 but " + scaleRow);
        scaleRow = Math.max(0, Math.min(scaleRow, 1));
    }
    if (scaleCol < 0 || scaleCol > 1) {
        Log.i(TAG, "The horizontal position of the anchor point should be at the range of 0" + " and 1 but " + scaleCol);
        scaleCol = Math.max(0, Math.min(scaleCol, 1));
    }
    int gravity = Gravity.CENTER;
    int horizontalMode = captionWindow.anchorId % ANCHOR_MODE_DIVIDER;
    int verticalMode = captionWindow.anchorId / ANCHOR_MODE_DIVIDER;
    float scaleStartRow = 0;
    float scaleEndRow = 1;
    float scaleStartCol = 0;
    float scaleEndCol = 1;
    switch(horizontalMode) {
        case ANCHOR_HORIZONTAL_MODE_LEFT:
            gravity = Gravity.LEFT;
            mCCView.setAlignment(Alignment.ALIGN_NORMAL);
            scaleStartCol = scaleCol;
            break;
        case ANCHOR_HORIZONTAL_MODE_CENTER:
            float gap = Math.min(1 - scaleCol, scaleCol);
            int columnCount = captionWindow.columnCount + 1;
            columnCount = Math.min(getScreenColumnCount(), columnCount);
            StringBuilder widestTextBuilder = new StringBuilder();
            for (int i = 0; i < columnCount; ++i) {
                widestTextBuilder.append(mWidestChar);
            }
            Paint paint = new Paint();
            paint.setTypeface(mCaptionStyle.getTypeface());
            paint.setTextSize(mTextSize);
            float maxWindowWidth = paint.measureText(widestTextBuilder.toString());
            float halfMaxWidthScale = mCCLayout.getWidth() > 0 ? maxWindowWidth / 2.0f / (mCCLayout.getWidth() * 0.8f) : 0.0f;
            if (halfMaxWidthScale > 0f && halfMaxWidthScale < scaleCol) {
                gravity = Gravity.LEFT;
                mCCView.setAlignment(Alignment.ALIGN_NORMAL);
                scaleStartCol = scaleCol - halfMaxWidthScale;
                scaleEndCol = 1.0f;
            } else {
                gravity = Gravity.CENTER_HORIZONTAL;
                mCCView.setAlignment(Alignment.ALIGN_CENTER);
                scaleStartCol = scaleCol - gap;
                scaleEndCol = scaleCol + gap;
            }
            break;
        case ANCHOR_HORIZONTAL_MODE_RIGHT:
            gravity = Gravity.RIGHT;
            mCCView.setAlignment(Alignment.ALIGN_RIGHT);
            scaleEndCol = scaleCol;
            break;
    }
    switch(verticalMode) {
        case ANCHOR_VERTICAL_MODE_TOP:
            gravity |= Gravity.TOP;
            scaleStartRow = scaleRow;
            break;
        case ANCHOR_VERTICAL_MODE_CENTER:
            gravity |= Gravity.CENTER_VERTICAL;
            float gap = Math.min(1 - scaleRow, scaleRow);
            scaleStartRow = scaleRow - gap;
            scaleEndRow = scaleRow + gap;
            break;
        case ANCHOR_VERTICAL_MODE_BOTTOM:
            gravity |= Gravity.BOTTOM;
            scaleEndRow = scaleRow;
            break;
    }
    mCCLayout.addOrUpdateViewToSafeTitleArea(this, new ScaledLayout.ScaledLayoutParams(scaleStartRow, scaleEndRow, scaleStartCol, scaleEndCol));
    setCaptionWindowId(captionWindow.id);
    setRowLimit(captionWindow.rowCount);
    setGravity(gravity);
    if (captionWindow.visible) {
        show();
    } else {
        hide();
    }
}