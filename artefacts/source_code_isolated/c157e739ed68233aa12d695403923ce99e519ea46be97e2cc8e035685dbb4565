public void aggregatePss(TotalMemoryUseCollection data, long now){
    final PssAggr fgPss = new PssAggr();
    final PssAggr bgPss = new PssAggr();
    final PssAggr cachedPss = new PssAggr();
    boolean havePss = false;
    for (int i = 0; i < mDurations.getKeyCount(); i++) {
        final int key = mDurations.getKeyAt(i);
        int type = SparseMappingTable.getIdFromKey(key);
        int procState = type % STATE_COUNT;
        long samples = getPssSampleCount(type);
        if (samples > 0) {
            long avg = getPssAverage(type);
            havePss = true;
            if (procState <= STATE_IMPORTANT_FOREGROUND) {
                fgPss.add(avg, samples);
            } else if (procState <= STATE_RECEIVER) {
                bgPss.add(avg, samples);
            } else {
                cachedPss.add(avg, samples);
            }
        }
    }
    if (!havePss) {
        return;
    }
    boolean fgHasBg = false;
    boolean fgHasCached = false;
    boolean bgHasCached = false;
    if (fgPss.samples < 3 && bgPss.samples > 0) {
        fgHasBg = true;
        fgPss.add(bgPss.pss, bgPss.samples);
    }
    if (fgPss.samples < 3 && cachedPss.samples > 0) {
        fgHasCached = true;
        fgPss.add(cachedPss.pss, cachedPss.samples);
    }
    if (bgPss.samples < 3 && cachedPss.samples > 0) {
        bgHasCached = true;
        bgPss.add(cachedPss.pss, cachedPss.samples);
    }
    if (bgPss.samples < 3 && !fgHasBg && fgPss.samples > 0) {
        bgPss.add(fgPss.pss, fgPss.samples);
    }
    if (cachedPss.samples < 3 && !bgHasCached && bgPss.samples > 0) {
        cachedPss.add(bgPss.pss, bgPss.samples);
    }
    if (cachedPss.samples < 3 && !fgHasCached && fgPss.samples > 0) {
        cachedPss.add(fgPss.pss, fgPss.samples);
    }
    for (int i = 0; i < mDurations.getKeyCount(); i++) {
        final int key = mDurations.getKeyAt(i);
        final int type = SparseMappingTable.getIdFromKey(key);
        long time = mDurations.getValue(key);
        if (mCurCombinedState == type) {
            time += now - mStartTime;
        }
        final int procState = type % STATE_COUNT;
        data.processStateTime[procState] += time;
        long samples = getPssSampleCount(type);
        long avg;
        if (samples > 0) {
            avg = getPssAverage(type);
        } else if (procState <= STATE_IMPORTANT_FOREGROUND) {
            samples = fgPss.samples;
            avg = fgPss.pss;
        } else if (procState <= STATE_RECEIVER) {
            samples = bgPss.samples;
            avg = bgPss.pss;
        } else {
            samples = cachedPss.samples;
            avg = cachedPss.pss;
        }
        double newAvg = ((data.processStatePss[procState] * (double) data.processStateSamples[procState]) + (avg * (double) samples)) / (data.processStateSamples[procState] + samples);
        data.processStatePss[procState] = (long) newAvg;
        data.processStateSamples[procState] += samples;
        data.processStateWeight[procState] += avg * (double) time;
    }
}