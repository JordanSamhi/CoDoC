public static NetworkStats javaReadNetworkStatsDetail(File detailPath, int limitUid, String[] limitIfaces, int limitTag) throws IOException{
    final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskReads();
    final NetworkStats stats = new NetworkStats(SystemClock.elapsedRealtime(), 24);
    final NetworkStats.Entry entry = new NetworkStats.Entry();
    int idx = 1;
    int lastIdx = 1;
    ProcFileReader reader = null;
    try {
        reader = new ProcFileReader(new FileInputStream(detailPath));
        reader.finishLine();
        while (reader.hasMoreData()) {
            idx = reader.nextInt();
            if (idx != lastIdx + 1) {
                throw new ProtocolException("inconsistent idx=" + idx + " after lastIdx=" + lastIdx);
            }
            lastIdx = idx;
            entry.iface = reader.nextString();
            entry.tag = kernelToTag(reader.nextString());
            entry.uid = reader.nextInt();
            entry.set = reader.nextInt();
            entry.rxBytes = reader.nextLong();
            entry.rxPackets = reader.nextLong();
            entry.txBytes = reader.nextLong();
            entry.txPackets = reader.nextLong();
            if ((limitIfaces == null || ArrayUtils.contains(limitIfaces, entry.iface)) && (limitUid == UID_ALL || limitUid == entry.uid) && (limitTag == TAG_ALL || limitTag == entry.tag)) {
                stats.insertEntry(entry);
            }
            reader.finishLine();
        }
    } catch (NullPointerException | NumberFormatException e) {
        throw protocolExceptionWithCause("problem parsing idx " + idx, e);
    } finally {
        IoUtils.closeQuietly(reader);
        StrictMode.setThreadPolicy(savedPolicy);
    }
    return stats;
}