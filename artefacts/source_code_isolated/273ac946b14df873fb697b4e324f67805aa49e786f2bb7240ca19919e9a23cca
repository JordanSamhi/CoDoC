public static String encode(String s, String allow){
    if (s == null) {
        return null;
    }
    StringBuilder encoded = null;
    int oldLength = s.length();
    int current = 0;
    while (current < oldLength) {
        int nextToEncode = current;
        while (nextToEncode < oldLength && isAllowed(s.charAt(nextToEncode), allow)) {
            nextToEncode++;
        }
        if (nextToEncode == oldLength) {
            if (current == 0) {
                return s;
            } else {
                encoded.append(s, current, oldLength);
                return encoded.toString();
            }
        }
        if (encoded == null) {
            encoded = new StringBuilder();
        }
        if (nextToEncode > current) {
            encoded.append(s, current, nextToEncode);
        } else {
        }
        current = nextToEncode;
        int nextAllowed = current + 1;
        while (nextAllowed < oldLength && !isAllowed(s.charAt(nextAllowed), allow)) {
            nextAllowed++;
        }
        String toEncode = s.substring(current, nextAllowed);
        try {
            byte[] bytes = toEncode.getBytes(DEFAULT_ENCODING);
            int bytesLength = bytes.length;
            for (int i = 0; i < bytesLength; i++) {
                encoded.append('%');
                encoded.append(HEX_DIGITS[(bytes[i] & 0xf0) >> 4]);
                encoded.append(HEX_DIGITS[bytes[i] & 0xf]);
            }
        } catch (UnsupportedEncodingException e) {
            throw new AssertionError(e);
        }
        current = nextAllowed;
    }
    return encoded == null ? s : encoded.toString();
}