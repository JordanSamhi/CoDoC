public void parse(String recur){
    resetFields();
    int parseFlags = 0;
    String[] parts;
    if (ALLOW_LOWER_CASE) {
        parts = recur.toUpperCase().split(";");
    } else {
        parts = recur.split(";");
    }
    for (String part : parts) {
        if (TextUtils.isEmpty(part)) {
            continue;
        }
        int equalIndex = part.indexOf('=');
        if (equalIndex <= 0) {
            throw new InvalidFormatException("Missing LHS in " + part);
        }
        String lhs = part.substring(0, equalIndex);
        String rhs = part.substring(equalIndex + 1);
        if (rhs.length() == 0) {
            throw new InvalidFormatException("Missing RHS in " + part);
        }
        PartParser parser = sParsePartMap.get(lhs);
        if (parser == null) {
            if (lhs.startsWith("X-")) {
                continue;
            }
            throw new InvalidFormatException("Couldn't find parser for " + lhs);
        } else {
            int flag = parser.parsePart(rhs, this);
            if ((parseFlags & flag) != 0) {
                throw new InvalidFormatException("Part " + lhs + " was specified twice");
            }
            parseFlags |= flag;
        }
    }
    if ((parseFlags & PARSED_WKST) == 0) {
        wkst = MO;
    }
    if ((parseFlags & PARSED_FREQ) == 0) {
        throw new InvalidFormatException("Must specify a FREQ value");
    }
    if ((parseFlags & (PARSED_UNTIL | PARSED_COUNT)) == (PARSED_UNTIL | PARSED_COUNT)) {
        if (ONLY_ONE_UNTIL_COUNT) {
            throw new InvalidFormatException("Must not specify both UNTIL and COUNT: " + recur);
        } else {
            Log.w(TAG, "Warning: rrule has both UNTIL and COUNT: " + recur);
        }
    }
}