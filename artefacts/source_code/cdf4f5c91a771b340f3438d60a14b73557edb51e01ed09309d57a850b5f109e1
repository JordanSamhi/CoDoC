public KeyEvent dispatchUnhandledKey(IBinder focusedToken, KeyEvent event, int policyFlags){
    if (DEBUG_INPUT) {
        final KeyInterceptionInfo info = mWindowManagerInternal.getKeyInterceptionInfoFromToken(focusedToken);
        final String title = info == null ? "<unknown>" : info.windowTitle;
        Slog.d(TAG, "Unhandled key: inputToken=" + focusedToken + ", title=" + title + ", action=" + event.getAction() + ", flags=" + event.getFlags() + ", keyCode=" + event.getKeyCode() + ", scanCode=" + event.getScanCode() + ", metaState=" + event.getMetaState() + ", repeatCount=" + event.getRepeatCount() + ", policyFlags=" + policyFlags);
    }
    KeyEvent fallbackEvent = null;
    if ((event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        final int keyCode = event.getKeyCode();
        final int metaState = event.getMetaState();
        final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0;
        final FallbackAction fallbackAction;
        if (initialDown) {
            fallbackAction = kcm.getFallbackAction(keyCode, metaState);
        } else {
            fallbackAction = mFallbackActions.get(keyCode);
        }
        if (fallbackAction != null) {
            if (DEBUG_INPUT) {
                Slog.d(TAG, "Fallback: keyCode=" + fallbackAction.keyCode + " metaState=" + Integer.toHexString(fallbackAction.metaState));
            }
            final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK;
            fallbackEvent = KeyEvent.obtain(event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), event.getDisplayId(), null);
            if (!interceptFallback(focusedToken, fallbackEvent, policyFlags)) {
                fallbackEvent.recycle();
                fallbackEvent = null;
            }
            if (initialDown) {
                mFallbackActions.put(keyCode, fallbackAction);
            } else if (event.getAction() == KeyEvent.ACTION_UP) {
                mFallbackActions.remove(keyCode);
                fallbackAction.recycle();
            }
        }
    }
    if (DEBUG_INPUT) {
        if (fallbackEvent == null) {
            Slog.d(TAG, "No fallback.");
        } else {
            Slog.d(TAG, "Performing fallback: " + fallbackEvent);
        }
    }
    return fallbackEvent;
}