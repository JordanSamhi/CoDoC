public static ShortcutLauncher loadFromXml(XmlPullParser parser, ShortcutUser shortcutUser, int ownerUserId, boolean fromBackup) throws IOException, XmlPullParserException{
    final String launcherPackageName = ShortcutService.parseStringAttribute(parser, ATTR_PACKAGE_NAME);
    final int launcherUserId = fromBackup ? ownerUserId : ShortcutService.parseIntAttribute(parser, ATTR_LAUNCHER_USER_ID, ownerUserId);
    final ShortcutLauncher ret = new ShortcutLauncher(shortcutUser, ownerUserId, launcherPackageName, launcherUserId);
    ArraySet<String> ids = null;
    final int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        final int depth = parser.getDepth();
        final String tag = parser.getName();
        if (depth == outerDepth + 1) {
            switch(tag) {
                case ShortcutPackageInfo.TAG_ROOT:
                    ret.getPackageInfo().loadFromXml(parser, fromBackup);
                    continue;
                case TAG_PACKAGE:
                    {
                        final String packageName = ShortcutService.parseStringAttribute(parser, ATTR_PACKAGE_NAME);
                        final int packageUserId = fromBackup ? ownerUserId : ShortcutService.parseIntAttribute(parser, ATTR_PACKAGE_USER_ID, ownerUserId);
                        ids = new ArraySet<>();
                        ret.mPinnedShortcuts.put(PackageWithUser.of(packageUserId, packageName), ids);
                        continue;
                    }
            }
        }
        if (depth == outerDepth + 2) {
            switch(tag) {
                case TAG_PIN:
                    {
                        if (ids == null) {
                            Slog.w(TAG, TAG_PIN + " in invalid place");
                        } else {
                            ids.add(ShortcutService.parseStringAttribute(parser, ATTR_VALUE));
                        }
                        continue;
                    }
            }
        }
        ShortcutService.warnForInvalidTag(depth, tag);
    }
    return ret;
}