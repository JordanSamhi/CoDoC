public String registerAudioPolicy(AudioPolicyConfig policyConfig, IAudioPolicyCallback pcb, boolean hasFocusListener, boolean isFocusPolicy, boolean isTestFocusPolicy, boolean isVolumeController, IMediaProjection projection){
    AudioSystem.setDynamicPolicyCallback(mDynPolicyCallback);
    if (!isPolicyRegisterAllowed(policyConfig, isFocusPolicy || isTestFocusPolicy || hasFocusListener, isVolumeController, projection)) {
        Slog.w(TAG, "Permission denied to register audio policy for pid " + Binder.getCallingPid() + " / uid " + Binder.getCallingUid() + ", need MODIFY_AUDIO_ROUTING or MediaProjection that can project audio");
        return null;
    }
    mDynPolicyLogger.log((new AudioEventLogger.StringEvent("registerAudioPolicy for " + pcb.asBinder() + " with config:" + policyConfig)).printLog(TAG));
    String regId = null;
    synchronized (mAudioPolicies) {
        if (mAudioPolicies.containsKey(pcb.asBinder())) {
            Slog.e(TAG, "Cannot re-register policy");
            return null;
        }
        try {
            AudioPolicyProxy app = new AudioPolicyProxy(policyConfig, pcb, hasFocusListener, isFocusPolicy, isTestFocusPolicy, isVolumeController, projection);
            pcb.asBinder().linkToDeath(app, 0);
            regId = app.getRegistrationId();
            mAudioPolicies.put(pcb.asBinder(), app);
        } catch (RemoteException e) {
            Slog.w(TAG, "Audio policy registration failed, could not link to " + pcb + " binder death", e);
            return null;
        } catch (IllegalStateException e) {
            Slog.w(TAG, "Audio policy registration failed for binder " + pcb, e);
            return null;
        }
    }
    return regId;
}