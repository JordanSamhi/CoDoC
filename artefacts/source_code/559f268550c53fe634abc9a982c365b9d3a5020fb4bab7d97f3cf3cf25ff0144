public void setAttribute(@NonNull String tag, @Nullable String value){
    if (tag == null) {
        throw new NullPointerException("tag shouldn't be null");
    }
    if (value != null && sTagSetForCompatibility.contains(tag)) {
        if (tag.equals(TAG_GPS_TIMESTAMP)) {
            Matcher m = sGpsTimestampPattern.matcher(value);
            if (!m.find()) {
                Log.w(TAG, "Invalid value for " + tag + " : " + value);
                return;
            }
            value = Integer.parseInt(m.group(1)) + "/1," + Integer.parseInt(m.group(2)) + "/1," + Integer.parseInt(m.group(3)) + "/1";
        } else {
            try {
                double doubleValue = Double.parseDouble(value);
                value = (long) (doubleValue * 10000L) + "/10000";
            } catch (NumberFormatException e) {
                Log.w(TAG, "Invalid value for " + tag + " : " + value);
                return;
            }
        }
    }
    for (int i = 0; i < EXIF_TAGS.length; ++i) {
        if (i == IFD_TYPE_THUMBNAIL && !mHasThumbnail) {
            continue;
        }
        final Object obj = sExifTagMapsForWriting[i].get(tag);
        if (obj != null) {
            if (value == null) {
                mAttributes[i].remove(tag);
                continue;
            }
            final ExifTag exifTag = (ExifTag) obj;
            Pair<Integer, Integer> guess = guessDataFormat(value);
            int dataFormat;
            if (exifTag.primaryFormat == guess.first || exifTag.primaryFormat == guess.second) {
                dataFormat = exifTag.primaryFormat;
            } else if (exifTag.secondaryFormat != -1 && (exifTag.secondaryFormat == guess.first || exifTag.secondaryFormat == guess.second)) {
                dataFormat = exifTag.secondaryFormat;
            } else if (exifTag.primaryFormat == IFD_FORMAT_BYTE || exifTag.primaryFormat == IFD_FORMAT_UNDEFINED || exifTag.primaryFormat == IFD_FORMAT_STRING) {
                dataFormat = exifTag.primaryFormat;
            } else {
                if (DEBUG) {
                    Log.d(TAG, "Given tag (" + tag + ") value didn't match with one of expected " + "formats: " + IFD_FORMAT_NAMES[exifTag.primaryFormat] + (exifTag.secondaryFormat == -1 ? "" : ", " + IFD_FORMAT_NAMES[exifTag.secondaryFormat]) + " (guess: " + IFD_FORMAT_NAMES[guess.first] + (guess.second == -1 ? "" : ", " + IFD_FORMAT_NAMES[guess.second]) + ")");
                }
                continue;
            }
            switch(dataFormat) {
                case IFD_FORMAT_BYTE:
                    {
                        mAttributes[i].put(tag, ExifAttribute.createByte(value));
                        break;
                    }
                case IFD_FORMAT_UNDEFINED:
                case IFD_FORMAT_STRING:
                    {
                        mAttributes[i].put(tag, ExifAttribute.createString(value));
                        break;
                    }
                case IFD_FORMAT_USHORT:
                    {
                        final String[] values = value.split(",");
                        final int[] intArray = new int[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            intArray[j] = Integer.parseInt(values[j]);
                        }
                        mAttributes[i].put(tag, ExifAttribute.createUShort(intArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_SLONG:
                    {
                        final String[] values = value.split(",");
                        final int[] intArray = new int[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            intArray[j] = Integer.parseInt(values[j]);
                        }
                        mAttributes[i].put(tag, ExifAttribute.createSLong(intArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_ULONG:
                    {
                        final String[] values = value.split(",");
                        final long[] longArray = new long[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            longArray[j] = Long.parseLong(values[j]);
                        }
                        mAttributes[i].put(tag, ExifAttribute.createULong(longArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_URATIONAL:
                    {
                        final String[] values = value.split(",");
                        final Rational[] rationalArray = new Rational[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            final String[] numbers = values[j].split("/");
                            rationalArray[j] = new Rational((long) Double.parseDouble(numbers[0]), (long) Double.parseDouble(numbers[1]));
                        }
                        mAttributes[i].put(tag, ExifAttribute.createURational(rationalArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_SRATIONAL:
                    {
                        final String[] values = value.split(",");
                        final Rational[] rationalArray = new Rational[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            final String[] numbers = values[j].split("/");
                            rationalArray[j] = new Rational((long) Double.parseDouble(numbers[0]), (long) Double.parseDouble(numbers[1]));
                        }
                        mAttributes[i].put(tag, ExifAttribute.createSRational(rationalArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_DOUBLE:
                    {
                        final String[] values = value.split(",");
                        final double[] doubleArray = new double[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            doubleArray[j] = Double.parseDouble(values[j]);
                        }
                        mAttributes[i].put(tag, ExifAttribute.createDouble(doubleArray, mExifByteOrder));
                        break;
                    }
                default:
                    if (DEBUG) {
                        Log.d(TAG, "Data format isn't one of expected formats: " + dataFormat);
                    }
                    continue;
            }
        }
    }
}