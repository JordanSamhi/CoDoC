public int configureOutputs(SparseArray<Surface> outputs, boolean validateSurfacesOnly){
    List<Pair<Surface, Size>> sizedSurfaces = new ArrayList<>();
    if (outputs != null) {
        int count = outputs.size();
        for (int i = 0; i < count; i++) {
            Surface output = outputs.valueAt(i);
            if (output == null) {
                Log.e(TAG, "configureOutputs - null outputs are not allowed");
                return BAD_VALUE;
            }
            if (!output.isValid()) {
                Log.e(TAG, "configureOutputs - invalid output surfaces are not allowed");
                return BAD_VALUE;
            }
            StreamConfigurationMap streamConfigurations = mStaticCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            try {
                Size s = getSurfaceSize(output);
                int surfaceType = detectSurfaceType(output);
                boolean flexibleConsumer = isFlexibleConsumer(output);
                Size[] sizes = streamConfigurations.getOutputSizes(surfaceType);
                if (sizes == null) {
                    if (surfaceType == ImageFormat.PRIVATE) {
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.YUV_420_888);
                    } else if (surfaceType == LegacyMetadataMapper.HAL_PIXEL_FORMAT_BLOB) {
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.JPEG);
                    }
                }
                if (!ArrayUtils.contains(sizes, s)) {
                    if (flexibleConsumer && (s = findClosestSize(s, sizes)) != null) {
                        sizedSurfaces.add(new Pair<>(output, s));
                    } else {
                        String reason = (sizes == null) ? "format is invalid." : ("size not in valid set: " + Arrays.toString(sizes));
                        Log.e(TAG, String.format("Surface with size (w=%d, h=%d) and format " + "0x%x is not valid, %s", s.getWidth(), s.getHeight(), surfaceType, reason));
                        return BAD_VALUE;
                    }
                } else {
                    sizedSurfaces.add(new Pair<>(output, s));
                }
                if (!validateSurfacesOnly) {
                    setSurfaceDimens(output, s.getWidth(), s.getHeight());
                }
            } catch (BufferQueueAbandonedException e) {
                Log.e(TAG, "Surface bufferqueue is abandoned, cannot configure as output: ", e);
                return BAD_VALUE;
            }
        }
    }
    if (validateSurfacesOnly) {
        return LegacyExceptionUtils.NO_ERROR;
    }
    boolean success = false;
    if (mDeviceState.setConfiguring()) {
        mRequestThreadManager.configure(sizedSurfaces);
        success = mDeviceState.setIdle();
    }
    if (success) {
        mConfiguredSurfaces = outputs;
    } else {
        return LegacyExceptionUtils.INVALID_OPERATION;
    }
    return LegacyExceptionUtils.NO_ERROR;
}